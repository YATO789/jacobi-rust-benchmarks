# Barrier Parallel 実装の詳細解説

## 概要

`barrier_parallel_02.rs` は、熱伝導シミュレーションを **2スレッド並列** で実行する実装です。
グリッドを上下に分割し、Barrier同期とMutexで境界データを共有しながら計算します。

---

## 1. データ分割の全体像

```
元のグリッド (N × M = 10 × 10)
┌─────────────────────────────┐
│ 行0  [0, 1, 2, ..., 9]      │ ┐
│ 行1  [10, 11, 12, ..., 19]  │ │
│ 行2  [20, 21, 22, ..., 29]  │ │ スレッド1が担当
│ 行3  [30, 31, 32, ..., 39]  │ │ (0..mid = 0..5)
│ 行4  [40, 41, 42, ..., 49]  │ ┘ ← upper_boundary に書き込み
├═════════════════════════════┤ ← 分割境界 (mid = 5)
│ 行5  [50, 51, 52, ..., 59]  │ ┐ ← lower_boundary に書き込み
│ 行6  [60, 61, 62, ..., 69]  │ │
│ 行7  [70, 71, 72, ..., 79]  │ │ スレッド2が担当
│ 行8  [80, 81, 82, ..., 89]  │ │ (mid..N = 5..10)
│ 行9  [90, 91, 92, ..., 99]  │ ┘
└─────────────────────────────┘
```

---

## 2. 初期化フェーズ

### データのコピーと分割

```rust
let mid = N / 2;  // 5

// データをコピーして分割
let upper_a: Vec<f64> = a.data[0..mid * M].to_vec();    // 要素0-49
let upper_b: Vec<f64> = b.data[0..mid * M].to_vec();    // 要素0-49
let lower_a: Vec<f64> = a.data[mid * M..N * M].to_vec(); // 要素50-99
let lower_b: Vec<f64> = b.data[mid * M..N * M].to_vec(); // 要素50-99
```

```
コピー後の状態:

upper_a (50要素)        lower_a (50要素)
┌──────────────┐       ┌──────────────┐
│ 0, 1, ..., 49│       │50, 51, ..., 99│
└──────────────┘       └──────────────┘
     ↓ move               ↓ move
  スレッド1             スレッド2
```

### 共有データ構造

```rust
// 境界行の共有バッファ
let upper_boundary = Arc::new(Mutex::new(vec![0.0; M])); // 10要素
let lower_boundary = Arc::new(Mutex::new(vec![0.0; M])); // 10要素

let barrier = Arc::new(Barrier::new(2));  // 2スレッド同期用
```

```
upper_boundary (Mutex)    lower_boundary (Mutex)
┌──────────────┐         ┌──────────────┐
│[0.0; 10]     │         │[0.0; 10]     │
└──────────────┘         └──────────────┘
   ↑       ↓               ↑       ↓
 書込    読込             書込    読込
   │       │               │       │
スレッド1 スレッド2      スレッド2 スレッド1
```

---

## 3. 1ステップの処理フロー

### フェーズ1: 境界行の書き込み

```
スレッド1                           スレッド2
────────                           ────────
┌──────────────┐                  ┌──────────────┐
│ 行4のデータを │                  │ 行5のデータを │
│upper_boundary│                  │lower_boundary│
│  に書き込み   │                  │  に書き込み   │
└──────────────┘                  └──────────────┘
      │                                  │
      │ {                                │ {
      │   let mut ub = upper_bound.lock()│   let mut lb = lower_bound.lock()
      │   for j in 0..M {                │   for j in 0..M {
      │     ub[j] = src[(mid-1)*M + j]   │     lb[j] = src[j]
      │   }                               │   }
      │ }  ← Mutex解放                   │ }  ← Mutex解放
      │                                  │
      ↓                                  ↓
```

**具体例:**
```
スレッド1が書き込む内容:
upper_boundary = [40, 41, 42, 43, 44, 45, 46, 47, 48, 49]
                 (グローバル行4のデータ)

スレッド2が書き込む内容:
lower_boundary = [50, 51, 52, 53, 54, 55, 56, 57, 58, 59]
                 (グローバル行5のデータ)
```

### フェーズ2: バリア同期 (1回目)

```
スレッド1                  スレッド2
   │                         │
   │                         │
   ↓                         ↓
barrier1.wait()        barrier2.wait()
   │                         │
   └────── 両方待機 ──────────┘
            │
            ↓
    両方のスレッドが境界を
    書き込むまでここで待つ
            │
            ↓
   ┌────── 解放 ──────────┐
   ↓                      ↓
```

### フェーズ3: 内部行の計算 (ロックフリー)

```
スレッド1: 行1, 2, 3を計算
┌─────────────────────────────┐
│ 行0  (境界、計算しない)      │
│ 行1  ✓ 計算 (ロックフリー)   │
│ 行2  ✓ 計算 (ロックフリー)   │
│ 行3  ✓ 計算 (ロックフリー)   │
│ 行4  (境界行、後で計算)      │
└─────────────────────────────┘

スレッド2: ローカル行1, 2, 3を計算 (グローバル行6, 7, 8)
┌─────────────────────────────┐
│ 行5  (境界行、後で計算)      │
│ 行6  ✓ 計算 (ロックフリー)   │
│ 行7  ✓ 計算 (ロックフリー)   │
│ 行8  ✓ 計算 (ロックフリー)   │
│ 行9  (境界、計算しない)      │
└─────────────────────────────┘
```

**5点ステンシルの計算:**
```
      上 (idx - M)
       │
左 ─── ● ─── 右
(idx-1)│(idx+1)
       │
      下 (idx + M)

laplacian = 上 + 下 + 左 + 右 - 4.0 * 中心
dst[idx] = src[idx] + factor * laplacian
```

### フェーズ4: 境界行の計算 (Mutex使用)

**スレッド1: 行4を計算**
```
行3  [30, 31, 32, 33, 34, 35, 36, 37, 38, 39]
行4  [40, 41, 42, 43, 44, 45, 46, 47, 48, 49] ← 計算中
              ↓上
            ┌───┐
        左← │ 43│ →右
            └───┘
              ↓下
   lower_boundary[3] = 53 ← スレッド2から取得
```

```rust
let lower_bound_row = lower_bound.lock().unwrap();
let i = mid - 1;  // 4
for j in 1..M-1 {
    let idx = i * M + j;
    let laplacian = lower_bound_row[j]  // ← 行5のデータ
        + src[idx - M]                   // 行3
        + src[idx + 1]                   // 右隣
        + src[idx - 1]                   // 左隣
        - 4.0 * src[idx];
    dst[idx] = src[idx] + factor * laplacian;
}
```

**スレッド2: 行5を計算**
```
   upper_boundary[3] = 43 ← スレッド1から取得
              ↓上
            ┌───┐
        左← │ 53│ →右
            └───┘
              ↓下
行5  [50, 51, 52, 53, 54, 55, 56, 57, 58, 59] ← 計算中
行6  [60, 61, 62, 63, 64, 65, 66, 67, 68, 69]
```

```rust
let upper_bound_row = upper_bound.lock().unwrap();
let i = 0;  // ローカル0 = グローバル5
for j in 1..M-1 {
    let idx = i * M + j;
    let laplacian = src[idx + M]         // 行6
        + upper_bound_row[j]             // ← 行4のデータ
        + src[idx + 1]                   // 右隣
        + src[idx - 1]                   // 左隣
        - 4.0 * src[idx];
    dst[idx] = src[idx] + factor * laplacian;
}
```

### フェーズ5: 熱源の固定

```
グリッド中央 (N/2, M/2) = (5, 5) を100度に固定

┌─────────────────────────────┐
│              ↓              │
│ 行5  [50, 51, 52, 53, 54, 🔥 ...] │
│                      ↑      │
│                  (5, 5) = 100.0   │
└─────────────────────────────┘
```

```rust
// スレッド2で処理（N/2 = 5 >= mid = 5）
if N / 2 >= mid {
    let heat_i = N / 2 - mid;  // 5 - 5 = 0
    dst[heat_i * M + M / 2] = 100.0;  // ローカル(0, 5)
}
```

### フェーズ6: バリア同期 (2回目)

```
スレッド1                  スレッド2
   │                         │
 計算完了                  計算完了
   ↓                         ↓
barrier1.wait()        barrier2.wait()
   │                         │
   └────── 両方待機 ──────────┘
            │
            ↓
    両方の計算が完了するまで
    ここで待つ
            │
            ↓
   ┌────── 解放 ──────────┐
   ↓                      ↓
```

### フェーズ7: ダブルバッファリング

```
swap前:
src = 計算済みデータ (古い時刻)
dst = 新しい計算結果 (新しい時刻)

std::mem::swap(&mut src, &mut dst)

swap後:
src = 新しい計算結果 (次のステップの入力)
dst = 古いデータ (次のステップの出力先)
```

---

## 4. 全体のタイムライン

```
時刻 │ スレッド1               │ スレッド2
─────┼─────────────────────────┼─────────────────────────
  0  │ upper_boundary書き込み  │ lower_boundary書き込み
     │         ↓               │         ↓
  1  │     barrier wait ───────┼──→ barrier wait
     │         ↓               │         ↓
  2  │ 内部行計算(1,2,3)       │ 内部行計算(6,7,8)
     │         ↓               │         ↓
  3  │ 境界行4計算(Mutex)      │ 境界行5計算(Mutex)
     │         ↓               │         ↓
  4  │ 熱源固定                │ 熱源固定
     │         ↓               │         ↓
  5  │     barrier wait ───────┼──→ barrier wait
     │         ↓               │         ↓
  6  │     swap                │     swap
     │         ↓               │         ↓
     │ (次のステップへ)        │ (次のステップへ)
```

---

## 5. 結果の統合

### スレッドの終了

```rust
// steps回のループが終了
if steps.is_multiple_of(2) { src } else { dst }
```

**swap回数と結果の関係:**
```
steps = 1: swap 1回  → 結果は dst に
steps = 2: swap 2回  → 結果は src に
steps = 3: swap 3回  → 結果は dst に
steps = 4: swap 4回  → 結果は src に
```

### データの書き戻し

```rust
let final_upper = upper_handle.join().unwrap();
let final_lower = lower_handle.join().unwrap();

a.data[0..mid * M].copy_from_slice(&final_upper);
a.data[mid * M..N * M].copy_from_slice(&final_lower);
```

```
統合:
┌──────────────┐
│ final_upper  │
│  (0-49)      │
├──────────────┤  →  a.data
│ final_lower  │
│  (50-99)     │
└──────────────┘
```

---

## 6. 最適化ポイント

### ロック範囲の最小化

```
全100セルのうち:
- Mutexでロック: 2行 × 8セル = 16セル (16%)
- ロックフリー: 6行 × 8セル = 48セル (48%)
- 境界セル(計算しない): 36セル (36%)
```

### データ局所性

```
スレッド1のキャッシュ:
┌──────────────┐
│ upper_a      │ ← メインデータ (連続アクセス)
│ upper_b      │
└──────────────┘
┌──────────────┐
│lower_boundary│ ← 1行のみ共有
└──────────────┘
```

### バリア同期の効率

```
不要な同期を排除:
❌ 各セルごとにロック
❌ 各行ごとにロック
✅ ステップごとに2回だけバリア同期
```

---

## 7. パフォーマンス特性

### 理論的スピードアップ

```
逐次実行: 8行 × 8セル × steps = 64 × steps 回の計算

並列実行:
- スレッド1: 4行 × 8セル × steps = 32 × steps
- スレッド2: 4行 × 8セル × steps = 32 × steps
並列実行時間 ≈ 32 × steps (2スレッドで並行)

理論スピードアップ ≈ 2倍
```

### オーバーヘッド

1. **初期コピー**: O(N×M)
2. **Mutexロック**: ステップごとに4回（各スレッド2回）
3. **バリア同期**: ステップごとに2回
4. **最終書き戻し**: O(N×M)

---

## 8. 境界データの流れ（詳細図解）

### 境界行のデータフロー

```
ステップN-1の最後                ステップNの開始
─────────────────────────────────────────────────────

スレッド1のメモリ:                スレッド1のメモリ:
┌────────────────┐               ┌────────────────┐
│ 行0            │               │ 行0            │
│ 行1            │               │ 行1            │
│ 行2            │               │ 行2            │
│ 行3            │               │ 行3            │
│ 行4 [40...49]  │──┐            │ 行4            │
└────────────────┘  │            └────────────────┘
                    │ 書込
                    ↓
            upper_boundary
            ┌──────────────┐
            │ [40...49]    │
            └──────────────┘
                    │ 読込
                    ↓
スレッド2のメモリ:                スレッド2のメモリ:
┌────────────────┐               ┌────────────────┐
│ 行5 [50...59]  │──┐            │ 行5 ← upper_boundary[j]を使用
│ 行6            │  │            │ 行6            │
│ 行7            │  │            │ 行7            │
│ 行8            │  │            │ 行8            │
│ 行9            │  │            │ 行9            │
└────────────────┘  │            └────────────────┘
                    │ 書込
                    ↓
            lower_boundary
            ┌──────────────┐
            │ [50...59]    │
            └──────────────┘
                    │ 読込
                    ↑
                    └────── スレッド1が行4計算時に使用
```

### 具体的な計算例（行4のセル43）

```
スレッド1が行4のセル43（インデックス=43）を計算する時:

        行3のセル33 (上)
              │
              ↓
     42 ←── [43] ──→ 44
  (左)       │      (右)
             ↓
   lower_boundary[3] = 53 (下)
   ※これはスレッド2が書き込んだ行5のデータ

laplacian = 33 + 53 + 42 + 44 - 4.0 * 43
          = 172 - 172
          = 0
dst[43] = 43 + factor * 0 = 43
```

### 具体的な計算例（行5のセル53）

```
スレッド2が行5のセル53（ローカルインデックス=3）を計算する時:

   upper_boundary[3] = 43 (上)
   ※これはスレッド1が書き込んだ行4のデータ
              │
              ↓
     52 ←── [53] ──→ 54
  (左)       │      (右)
             ↓
        行6のセル63 (下)

laplacian = 43 + 63 + 52 + 54 - 4.0 * 53
          = 212 - 212
          = 0
dst[3] = 53 + factor * 0 = 53
```

---

## 9. メモリレイアウトとインデックス変換

### スレッド1のインデックス

```
グローバルインデックス = ローカルインデックス

行0: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
行1: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
行2: 20, 21, 22, 23, 24, 25, 26, 27, 28, 29
行3: 30, 31, 32, 33, 34, 35, 36, 37, 38, 39
行4: 40, 41, 42, 43, 44, 45, 46, 47, 48, 49
```

### スレッド2のインデックス変換

```
ローカル → グローバル変換

ローカル行0: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9    → グローバル行5
ローカル行1: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 → グローバル行6
ローカル行2: 20, 21, 22, 23, 24, 25, 26, 27, 28, 29 → グローバル行7
ローカル行3: 30, 31, 32, 33, 34, 35, 36, 37, 38, 39 → グローバル行8
ローカル行4: 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 → グローバル行9

変換式: グローバル行 = ローカル行 + mid
       グローバルidx = ローカルidx + mid * M
```

---

## まとめ

この実装は以下の特徴を持ちます:

1. **グリッド分割**: 上下2つに分割して並列処理
2. **境界共有**: Mutexで境界行のみを共有
3. **バリア同期**: 計算の整合性を保証
4. **ロックフリー化**: 内部計算の75%はロック不要
5. **ダブルバッファリング**: メモリ効率の良い更新

結果として、ロックのオーバーヘッドを最小限に抑えながら、
安全な並列実行を実現しています。
