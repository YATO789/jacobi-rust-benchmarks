# ベンチマーク測定戦略

## 研究目的の確認

1. **C vs Rust (Unsafe)**: コンパイラとバックエンドの純粋な性能差
2. **Rust Safe vs Rust Unsafe**: 安全性機能のランタイムオーバーヘッド
3. **同期方式の比較**: Semaphore vs Barrier vs Rayon

---

## パラメータ設定の方針

### 測定すべき次元

1. **計算量（グリッドサイズ）**: キャッシュ効果、メモリ帯域の影響を測定
2. **時間ステップ数**: 同期オーバーヘッドの累積効果を測定
3. **実装方式**: 並列化戦略の違いを測定

---

## 推奨パラメータセット

### Phase 1: キャッシュ階層の調査（ステップ数固定）

**目的**: キャッシュサイズの影響を測定し、最適なグリッドサイズを見つける

| グリッドサイズ | 総要素数 | メモリ使用量 (2 grids) | キャッシュレベル | ステップ数 |
|---------------|---------|----------------------|--------------|----------|
| 256×256 | 65,536 | ~1 MB | L2キャッシュ内 | 100 |
| 512×512 | 262,144 | ~4 MB | L2/L3境界 | 100 |
| 1024×1024 | 1,048,576 | ~16 MB | L3キャッシュ内 | 100 |
| 2048×2048 | 4,194,304 | ~64 MB | L3超過 | 100 |
| 4096×4096 | 16,777,216 | ~256 MB | メインメモリ | 100 |

**Apple M3のキャッシュ構成**:
- L1: 128KB (data) per core
- L2: 4MB per core
- Shared Cache: 16MB-24MB

**期待される結果**:
- 小サイズ: キャッシュヒット率高い → 最速
- 中サイズ: キャッシュミス増加 → 性能低下
- 大サイズ: メモリ帯域律速 → さらに低下

---

### Phase 2: 同期オーバーヘッドの調査（グリッドサイズ固定）

**目的**: 同期回数が性能に与える影響を測定

**グリッドサイズ**: 1024×1024（L3キャッシュ内、安定した測定が可能）

| ステップ数 | 総同期回数 (Safe) | 総同期回数 (Unsafe) | 計算時間の期待値 |
|-----------|------------------|-------------------|----------------|
| 10 | 20回 | 10回 | 短い（ウォームアップ不足注意） |
| 50 | 100回 | 50回 | 中程度 |
| 100 | 200回 | 100回 | **推奨値** |
| 200 | 400回 | 200回 | 長い |
| 500 | 1000回 | 500回 | 非常に長い |

**期待される結果**:
- Rust Safe版: ステップ数に比例してオーバーヘッド増加（2回同期/ステップ）
- C/Unsafe版: 同期回数半分 → オーバーヘッド小

**推奨**: 100ステップをベースライン、200ステップで傾向確認

---

### Phase 3: スケーラビリティ調査（両軸変化）

**目的**: 計算量と同期の相互作用を測定

| グリッドサイズ | ステップ数 | 総計算量 | 測定目的 |
|---------------|----------|---------|---------|
| 512×512 | 50 | 中規模 | キャッシュ効率良好 |
| 1024×1024 | 100 | **ベースライン** | 標準測定 |
| 2048×2048 | 100 | 大規模 | メモリ帯域測定 |
| 1024×1024 | 200 | 同期負荷 | 同期コスト測定 |
| 2048×2048 | 200 | 最大負荷 | 限界性能測定 |

---

## 実行スクリプト例

### Phase 1: グリッドサイズ変化

```bash
#!/bin/bash
# phase1_grid_size.sh

STEP=100

for SIZE in 256 512 1024 2048 4096; do
    echo "=== Grid Size: ${SIZE}x${SIZE}, Steps: ${STEP} ==="
    ./run_benchmark.sh -n ${SIZE} -s ${STEP}
    sleep 10  # システム冷却
done
```

### Phase 2: ステップ数変化

```bash
#!/bin/bash
# phase2_time_steps.sh

GRID=1024

for STEP in 10 50 100 200 500; do
    echo "=== Grid Size: ${GRID}x${GRID}, Steps: ${STEP} ==="
    ./run_benchmark.sh -n ${GRID} -s ${STEP}
    sleep 10
done
```

### Phase 3: マトリックス測定

```bash
#!/bin/bash
# phase3_matrix.sh

declare -a SIZES=(512 1024 2048)
declare -a STEPS=(50 100 200)

for SIZE in "${SIZES[@]}"; do
    for STEP in "${STEPS[@]}"; do
        echo "=== Grid: ${SIZE}x${SIZE}, Steps: ${STEP} ==="
        ./run_benchmark.sh -n ${SIZE} -s ${STEP}
        sleep 10
    done
done
```

---

## 測定上の注意点

### 1. システム状態の管理

**推奨事項**:
- ✅ バックグラウンドプロセスを最小化
- ✅ 測定間に十分なクールダウン時間（5-10秒）
- ✅ 電源接続状態で実行（バッテリー節約モードOFF）
- ✅ 同じ時間帯に測定（CPU温度の影響を最小化）

**確認コマンド**:
```bash
# CPU温度確認（macOS）
sudo powermetrics -n 1 -i 1000 | grep -i "CPU die temperature"

# バックグラウンドプロセス確認
top -l 1 | head -20
```

### 2. 統計的信頼性

**現在の設定**:
- 測定回数: 15回
- ウォームアップ: 3回
- 統計量: 最小値、中央値、平均値、最大値

**推奨**:
- ✅ 中央値を主要指標として使用（外れ値の影響を受けにくい）
- ✅ 標準偏差を確認（5%以下が理想）
- ⚠️ 最小値は参考程度（ノイズの影響大）

### 3. 測定時間の見積もり

**単一測定時間** = (ウォームアップ3回 + 本番15回) × 実行時間 + クールダウン時間

| グリッドサイズ | ステップ数 | 推定実行時間/回 | 総測定時間 (18回) |
|---------------|----------|----------------|-----------------|
| 256×256 | 100 | ~5ms | ~2分 |
| 512×512 | 100 | ~15ms | ~5分 |
| 1024×1024 | 100 | ~40ms | ~15分 |
| 2048×2048 | 100 | ~160ms | ~60分 |
| 4096×4096 | 100 | ~650ms | ~4時間 |

**Phase 1完了時間**: 約5-6時間
**Phase 2完了時間**: 約1.5時間
**Phase 3完了時間**: 約6-8時間

---

## 推奨測定順序

### 最小限の測定セット（研究発表用）

**優先度1: ベースライン測定**
```bash
./run_benchmark.sh -n 1024 -s 100  # 標準条件
./run_benchmark.sh -n 2048 -s 100  # スケーラビリティ確認
```

**優先度2: キャッシュ効果測定**
```bash
./run_benchmark.sh -n 512 -s 100   # L2/L3境界
./run_benchmark.sh -n 4096 -s 100  # メモリ帯域測定
```

**優先度3: 同期コスト測定**
```bash
./run_benchmark.sh -n 1024 -s 50   # 低同期
./run_benchmark.sh -n 1024 -s 200  # 高同期
```

### 完全な測定セット（論文用）

Phase 1 + Phase 2 + Phase 3 を全て実行

---

## データ分析の観点

### 1. 性能比（Speedup/Slowdown）

```
Speedup(Rust Safe) = Time(C) / Time(Rust Safe)
Speedup(Rust Unsafe) = Time(C) / Time(Rust Unsafe)
Safety Cost = Time(Rust Safe) / Time(Rust Unsafe)
```

**期待される結果**:
- Speedup > 1.0: Rustの方が速い
- Speedup < 1.0: Cの方が速い
- Safety Cost > 1.0: 安全性にコストあり

### 2. スケーリング効率

```
Efficiency(size) = Performance(size) / (size^2)
```

理想的には、グリッドサイズが4倍 → 計算時間も4倍

### 3. 同期オーバーヘッド

```
Sync Overhead = (Time - Time_compute) / Time
```

ステップ数を変化させて測定

---

## ベンチマーク結果の可視化

### グラフの種類

1. **グリッドサイズ vs 実行時間**
   - X軸: グリッドサイズ（対数スケール）
   - Y軸: 実行時間（ms）
   - 線: 各実装

2. **ステップ数 vs 実行時間**
   - X軸: ステップ数
   - Y軸: 実行時間（ms）
   - 線: 各実装

3. **安全性コストのヒートマップ**
   - X軸: グリッドサイズ
   - Y軸: ステップ数
   - 色: Safety Cost比率

4. **相対性能比較（バーチャート）**
   - X軸: 実装
   - Y軸: Speedup（C = 1.0基準）

---

## 結果の解釈ガイド

### Cが速い場合
- LLVMバックエンドの最適化差
- Rustの追加チェック
- メモリレイアウトの違い

### Rust Safeが速い場合
- Rustの高度な最適化（LLVM最新版）
- ゼロコスト抽象化の効果
- アライメント最適化

### Rust Unsafeが最速の場合
- 境界チェック除去の効果
- 直接メモリアクセスの効率
- アグレッシブな最適化

### 安全性コストが大きい場合
- 境界チェックの累積効果
- Mutexロックのオーバーヘッド
- 追加同期の影響

---

## 最終推奨パラメータセット

### クイックテスト（30分）
```bash
# 基本性能確認
./run_benchmark.sh -n 1024 -s 100
./run_benchmark.sh -n 2048 -s 100
```

### 標準測定（3時間）
```bash
# グリッドサイズ変化
for SIZE in 512 1024 2048; do
    ./run_benchmark.sh -n ${SIZE} -s 100
done

# ステップ数変化
for STEP in 50 100 200; do
    ./run_benchmark.sh -n 1024 -s ${STEP}
done
```

### フル測定（8-10時間）
```bash
# Phase 1: Grid size sweep
for SIZE in 256 512 1024 2048 4096; do
    ./run_benchmark.sh -n ${SIZE} -s 100
done

# Phase 2: Time step sweep
for STEP in 10 50 100 200 500; do
    ./run_benchmark.sh -n 1024 -s ${STEP}
done

# Phase 3: Matrix measurement
for SIZE in 512 1024 2048; do
    for STEP in 50 100 200; do
        ./run_benchmark.sh -n ${SIZE} -s ${STEP}
    done
done
```

---

## 補足: パラメータ選定の理論的根拠

### グリッドサイズの選択

**256×256 (65K要素, ~512KB)**
- L2キャッシュ内（M3の4MB L2に余裕で収まる）
- キャッシュ効率最大
- 同期オーバーヘッドが相対的に大きく見える

**1024×1024 (1M要素, ~8MB)**
- L3キャッシュ内（M3の16-24MB共有キャッシュに収まる）
- **推奨ベースライン**
- 計算時間が適度（~40ms）
- 安定した測定が可能

**2048×2048 (4M要素, ~32MB)**
- L3キャッシュを超える
- メモリ帯域の影響が顕著
- スケーラビリティ測定に最適

**4096×4096 (16M要素, ~128MB)**
- 完全にメインメモリ
- メモリ帯域律速
- 極限性能測定

### ステップ数の選択

**10ステップ**
- 高速測定（デバッグ用）
- ウォームアップ不足の可能性
- 同期回数少ない → 差が小さい

**100ステップ（推奨）**
- 測定時間適度（~40ms @ 1024²）
- 統計的に安定
- 同期効果が明確

**500ステップ**
- 長時間測定
- 同期オーバーヘッドの累積測定
- サーマルスロットリングに注意

---

## まとめ

**最小限の測定で最大の知見を得る推奨セット**:

1. **n=1024, s=100**: ベースライン（必須）
2. **n=2048, s=100**: スケーラビリティ
3. **n=1024, s=200**: 同期コスト

この3点で、主要な性能特性を把握可能。時間があればグリッドサイズ512と4096を追加。
