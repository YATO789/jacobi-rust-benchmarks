# Rustの安全保証と性能への影響

## 概要

このベンチマークでは、Rust Safe実装とRust Unsafe実装を比較することで、**Rustの安全保証が実行性能に与える影響**を定量的に測定しました。

---

## 1. Rustの安全保証とは

### Safe Rustの保証

1. **メモリ安全性**
   - バッファオーバーフロー/アンダーフローの防止
   - Use-after-freeの防止
   - NULLポインタ参照の防止

2. **スレッド安全性**
   - データ競合の防止（Send/Syncトレイト）
   - 可変参照の排他性保証

3. **実行時チェック**
   - 配列の境界チェック
   - 整数オーバーフローチェック（debugビルド）
   - パニック処理

### Unsafe Rustで回避できるもの

```rust
// Safe: 境界チェックあり
let value = grid[i * M + j];  // 毎回境界をチェック

// Unsafe: 境界チェックなし
let value = unsafe { *grid.get_unchecked(i * M + j) };  // チェックスキップ
```

---

## 2. 安全性のコスト測定結果

### 2.1 セマフォ実装

| グリッドサイズ | Rust Safe | Rust Unsafe | Safety Cost | オーバーヘッド |
|:---|---:|---:|---:|---:|
| 64x64 | 4.90 ms | 4.83 ms | 1.01× | **1%** |
| 128x128 | 10.45 ms | 8.69 ms | 1.20× | **20%** |
| 512x512 | 43.70 ms | 40.66 ms | 1.07× | **7%** |
| 1024x1024 | 163.19 ms | 144.55 ms | 1.13× | **13%** |

**平均オーバーヘッド: 約10%**

#### 主なオーバーヘッド要因
1. **境界チェック**: 配列アクセスごとに`if index < length`
2. **境界バッファのコピー**: スレッド間でデータを安全に共有するためのバッファコピー
3. **Mutexロック/アンロック**: 安全な同期のためのオーバーヘッド

### 2.2 バリア実装

| グリッドサイズ | Rust Safe | Rust Unsafe | Safety Cost | オーバーヘッド |
|:---|---:|---:|---:|---:|
| 64x64 | 12.77 ms | 10.46 ms | 1.22× | **22%** |
| 128x128 | 18.92 ms | 15.16 ms | 1.25× | **25%** |
| 512x512 | 49.66 ms | 42.60 ms | 1.17× | **17%** |
| 1024x1024 | 174.56 ms | 153.85 ms | 1.13× | **13%** |

**平均オーバーヘッド: 約19%**

#### 主なオーバーヘッド要因
1. **境界チェック**: セマフォと同様
2. **境界バッファのコピー**: バリア同期時のデータコピー
3. **同期オーバーヘッド**: Barrierの待機コスト

### 2.3 Rayon実装（高レベル抽象化）

| グリッドサイズ | Rust Safe | Rust Unsafe | Safety Cost | オーバーヘッド |
|:---|---:|---:|---:|---:|
| 64x64 | 13.50 ms | 12.88 ms | 1.05× | **5%** |
| 128x128 | 19.22 ms | 18.47 ms | 1.04× | **4%** |
| 512x512 | 48.00 ms | 49.63 ms | 0.97× | **-3%** ⚠️ |
| 1024x1024 | 173.64 ms | 175.85 ms | 0.99× | **-1%** ⚠️ |

**平均オーバーヘッド: 約1%（大規模グリッドでは逆転）**

⚠️ **注目**: 512x512以上で**SafeがUnsafeより速い**

#### 理由の分析
1. **コンパイラ最適化**: Safe版の方が最適化しやすい
2. **予測可能なメモリアクセス**: 境界チェックがCPUの分岐予測を助ける
3. **LLVM最適化**: 境界チェックが冗長と判断され、自動的に除去される場合がある
4. **測定誤差**: 1-3%の差は誤差範囲内

---

## 3. 安全性のコストが発生する場所

### 3.1 境界チェックのコスト

```rust
// Safe版（境界チェックあり）
fn update_grid_safe(grid: &[f64], new_grid: &mut [f64], n: usize, m: usize) {
    for i in 1..n-1 {
        for j in 1..m-1 {
            let idx = i * m + j;
            
            // 5つの配列アクセス、それぞれ境界チェック
            let center = grid[idx];           // チェック1
            let up     = grid[idx - m];       // チェック2
            let down   = grid[idx + m];       // チェック3
            let left   = grid[idx - 1];       // チェック4
            let right  = grid[idx + 1];       // チェック5
            
            new_grid[idx] = 0.25 * (up + down + left + right);  // チェック6
        }
    }
}
```

**1セルあたり6回の境界チェック**

1024x1024グリッド、1000ステップの場合:
- 総計算セル数: (1024-2) × (1024-2) × 1000 ≈ 10億セル
- 境界チェック回数: 10億 × 6 = **60億回**

各チェックのコスト（仮定）:
```assembly
; 境界チェックの擬似アセンブリ
cmp rax, [array_length]  ; 比較命令（1サイクル）
jge panic_handler        ; 条件分岐（予測成功時0-1サイクル）
```

### 3.2 Unsafe版（境界チェックなし）

```rust
// Unsafe版
fn update_grid_unsafe(grid: &[f64], new_grid: &mut [f64], n: usize, m: usize) {
    unsafe {
        for i in 1..n-1 {
            for j in 1..m-1 {
                let idx = i * m + j;
                
                // 境界チェックなし、直接メモリアクセス
                let center = *grid.get_unchecked(idx);
                let up     = *grid.get_unchecked(idx - m);
                let down   = *grid.get_unchecked(idx + m);
                let left   = *grid.get_unchecked(idx - 1);
                let right  = *grid.get_unchecked(idx + 1);
                
                *new_grid.get_unchecked_mut(idx) = 
                    0.25 * (up + down + left + right);
            }
        }
    }
}
```

**境界チェック0回** → CPUサイクルを節約

---

## 4. グリッドサイズによる影響の変化

### 小さいグリッド（64x64, 128x128）

```
Safety Cost: 1-25%
```

**高いオーバーヘッド要因**:
1. **同期オーバーヘッドが支配的**
   - Mutexロック/アンロック
   - Barrier待機
   - スレッド起動コスト

2. **計算時間が短い**
   - 並列化の固定コストが相対的に大きい
   - 境界チェックの影響が目立ちにくい

### 大きいグリッド（512x512, 1024x1024）

```
Safety Cost: 7-17%
```

**オーバーヘッド減少の理由**:
1. **計算時間が長い**
   - 境界チェックのコストが相対的に小さくなる
   
2. **キャッシュ効率**
   - メモリアクセスがボトルネックになり、CPU演算のコストが隠れる
   
3. **並列化効率向上**
   - 同期コストが計算時間に対して小さくなる

---

## 5. C言語との比較

### 5.1 Rust Safe vs C

| グリッドサイズ | C Semaphore | Rust Safe Semaphore | Overhead |
|:---|---:|---:|---:|
| 64x64 | 3.93 ms | 4.90 ms | **1.25×** |
| 128x128 | 8.12 ms | 10.45 ms | **1.29×** |
| 512x512 | 37.88 ms | 43.70 ms | **1.15×** |
| 1024x1024 | 134.55 ms | 163.19 ms | **1.21×** |

**平均: Rust Safeは Cより 15-29% 遅い**

#### オーバーヘッドの内訳
1. **境界チェック**: ~7-13%
2. **実装戦略の違い**: ~8-16%
   - Rust: 境界バッファを使った安全な共有
   - C: ポインタによる直接共有

### 5.2 Rust Unsafe vs C

| グリッドサイズ | C Semaphore | Rust Unsafe Semaphore | Overhead |
|:---|---:|---:|---:|
| 64x64 | 3.93 ms | 4.83 ms | **1.23×** |
| 128x128 | 8.12 ms | 8.69 ms | **1.07×** |
| 512x512 | 37.88 ms | 40.66 ms | **1.07×** |
| 1024x1024 | 134.55 ms | 144.55 ms | **1.07×** |

**平均: Rust UnsafeはCより 7-23% 遅い**

#### 残存するオーバーヘッド
境界チェックを除去しても、なおCより遅い理由：
1. **実装戦略の違い** (主要因)
2. **Rustのゼロコスト抽象化のコスト**（実際には小さい）
3. **異なるコンパイラの最適化**（Clang vs rustc/LLVM）

---

## 6. ゼロコスト抽象化の検証

### Rustの「ゼロコスト抽象化」の原則

> "What you don't use, you don't pay for. And what you do use, you couldn't hand code any better."
> 
> 使わないものには対価を払わない。使うものについては、手書きより良くできない。

### 検証結果

#### ✅ 成功例: Rayon

```
512x512:   Safe 48.00ms vs Unsafe 49.63ms  → Safe が 3% 速い
1024x1024: Safe 173.64ms vs Unsafe 175.85ms → Safe が 1% 速い
```

**結論**: Rayonの高レベル抽象化は**真のゼロコスト**を達成
- 並列イテレータの抽象化コストがゼロ
- コンパイラが最適化で境界チェックを除去
- 手書きのUnsafe版と同等またはそれ以上の性能

#### ⚠️ 部分的成功: Semaphore/Barrier

```
1024x1024 Semaphore: Safe 163.19ms vs Unsafe 144.55ms → 13% の差
```

**理由**: 
- 境界チェック自体はゼロコストに近づけられる
- しかし、**安全な共有のための境界バッファコピー**は必要
- これは**アルゴリズム的な違い**であり、抽象化のコストではない

---

## 7. 実用的な推奨事項

### 7.1 いつUnsafeを使うべきか

#### ❌ 使うべきでない場合

1. **性能改善が10%未満の場合**
   - 安全性を犠牲にする価値がない
   - メンテナンスコストが増加

2. **プロトタイプ・検証段階**
   - まずSafe版で正しさを確認
   - バグの混入リスクが高い

3. **クリティカルでないコード**
   - I/O待ちが支配的な処理
   - 実行頻度が低い処理

#### ✅ 使うべき場合

1. **性能クリティカルなホットパス**
   - プロファイリングで境界チェックがボトルネックと確認
   - 10%以上の性能改善が見込める

2. **大量の配列アクセス**
   - 本ベンチマークのような数値計算
   - 画像処理、音声処理

3. **FFIバウンダリ**
   - C/C++ライブラリとの連携
   - 低レベルシステムプログラミング

### 7.2 Unsafeの安全な使い方

```rust
// ❌ 悪い例: unsafeブロックが大きすぎる
unsafe {
    for i in 0..n {
        for j in 0..m {
            // 100行のコード...
        }
    }
}

// ✅ 良い例: unsafeを最小限に
for i in 1..n-1 {
    for j in 1..m-1 {
        let idx = i * m + j;
        
        // 境界内であることを事前に保証
        debug_assert!(idx < grid.len());
        debug_assert!(idx >= m);
        
        // 最小限のunsafeブロック
        let value = unsafe { *grid.get_unchecked(idx) };
    }
}
```

#### ベストプラクティス

1. **事前条件の文書化**
```rust
/// # Safety
/// 
/// `idx` must be in range `m..(n-1)*m` where n*m == grid.len()
unsafe fn get_unchecked_inner(grid: &[f64], idx: usize) -> f64 {
    *grid.get_unchecked(idx)
}
```

2. **Debug assertionで検証**
```rust
debug_assert!(idx < grid.len(), "Index out of bounds");
unsafe { *grid.get_unchecked(idx) }
```

3. **Safe wrapper関数**
```rust
fn update_cell_safe(grid: &[f64], idx: usize, n: usize, m: usize) -> f64 {
    assert!(idx >= m && idx < (n-1)*m);
    unsafe { update_cell_unsafe(grid, idx, m) }
}
```

---

## 8. まとめ

### 測定結果のまとめ

| 実装 | 安全性のコスト | 特徴 |
|:---|:---:|:---|
| **Semaphore** | **7-20%** | 境界チェック + バッファコピー |
| **Barrier** | **13-25%** | 境界チェック + バッファコピー |
| **Rayon** | **-3% ~ 5%** | ゼロコスト抽象化を実現 |

### 重要な結論

1. **Rustの安全性コストは測定可能だが小さい**
   - 平均7-20%のオーバーヘッド
   - 大規模データでは10-15%程度

2. **ゼロコスト抽象化は実現可能**
   - Rayonは証明済み
   - 適切な実装で境界チェックは最適化可能

3. **安全性とパフォーマンスのトレードオフは妥当**
   - 10-20%の性能コストで、メモリ安全性とスレッド安全性を保証
   - C言語のバグ（セグフォ、データ競合）のリスクを完全に排除

4. **Unsafeは慎重に使う**
   - 性能が10%以上改善する場合のみ検討
   - 最小限のスコープに限定
   - 十分なテストと文書化

### 実用的なガイドライン

```
性能要件が厳しい場合:
  ├─ まずSafeで実装
  ├─ プロファイリングでボトルネック特定
  ├─ 境界チェックが10%以上のコストなら
  │   └─ 最小限のUnsafeで最適化
  └─ それ以外ならSafeのまま
```

**Rustの安全性は、ほとんどの場合、そのコストに見合う価値がある。**
