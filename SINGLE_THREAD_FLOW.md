# 逐次処理（シングルスレッド）のフロー

## コード全体
```rust
pub fn jacobi_step(a: &mut Grid, b: &mut Grid, steps: usize) {
    let factor = ALPHA * DT / (DX * DX);  // = 0.01

    for _ in 0..steps {
        // 1. 内部格子点を走査
        for i in 1..N-1 {
            for j in 1..M-1 {
                let idx = i * M + j;

                // 2. 5点ステンシル（Laplacian）計算
                let laplacian = a[上] + a[下] + a[左] + a[右] - 4.0 * a[中心];

                // 3. 新しい値を計算
                b[idx] = a[idx] + factor * laplacian;
            }
        }

        // 4. 熱源を固定値に戻す
        b[中央] = 100.0;

        // 5. ダブルバッファリング（ポインタ交換）
        swap(a, b);
    }
}
```

---

## フローチャート

```
[開始] factor = 0.01
   ↓
┌─────────────────┐
│ ステップループ  │ ← steps回繰り返し（例: 100回）
│  (0..steps)     │
└────────┬────────┘
         ↓
    ┌─────────┐
    │ 行ループ │ ← i = 1..N-1（境界を除く）
    │ (i)     │
    └────┬────┘
         ↓
    ┌─────────┐
    │ 列ループ │ ← j = 1..M-1（境界を除く）
    │ (j)     │
    └────┬────┘
         ↓
    ┌──────────────────┐
    │ 5点ステンシル計算│
    │  上+下+左+右-4中心│
    └────┬─────────────┘
         ↓
    ┌──────────────────┐
    │ 新しい値を計算   │
    │ b[i,j] = a[i,j]  │
    │    + 0.01×Δ²     │
    └────┬─────────────┘
         ↓
    全格子点完了？
         ↓ Yes
    ┌──────────────┐
    │ 熱源固定     │ b[中央] = 100.0
    └────┬─────────┘
         ↓
    ┌──────────────┐
    │ swap(a, b)   │ ← ポインタ交換（データコピーなし）
    └────┬─────────┘
         ↓
    全ステップ完了？
         ↓ Yes
      [終了]
```

---

## 5点ステンシル計算の図解

### 格子点の配置
```
           a[i-1, j]
              (上)
               ↓
a[i, j-1] → a[i, j] ← a[i, j+1]
  (左)      (中心)       (右)
               ↑
           a[i+1, j]
              (下)
```

### Laplacian計算式
```
laplacian = a[上] + a[下] + a[左] + a[右] - 4 × a[中心]
```

### 熱拡散の直感的理解
- **laplacian > 0**: 周囲が高温 → 熱が流入 → 温度上昇
- **laplacian < 0**: 周囲が低温 → 熱が流出 → 温度低下
- **laplacian = 0**: 平衡状態 → 温度変化なし

---

## ダブルバッファリング

### なぜ必要？
```
❌ 単一バッファ（誤り）:
   a[i,j] = f(a[i-1,j], a[i,j-1], ...)
   → 既に更新された値を読んでしまう！

✅ ダブルバッファ（正解）:
   b[i,j] = f(a[i-1,j], a[i,j-1], ...)  ← aから読み、bに書く
   swap(a, b)  ← ポインタ交換（高速）
```

### 動作イメージ
```
ステップ0:  [a: 読み取り] → 計算 → [b: 書き込み]
              ↓
           swap(a, b)
              ↓
ステップ1:  [b: 読み取り] → 計算 → [a: 書き込み]
              ↓
           swap(a, b)
              ↓
           ...
```

---

## 計算例（4×4グリッド、1ステップ）

### 初期状態
```
0.0   0.0   0.0   0.0   ← 境界（固定）
0.0   0.0   0.0   0.0
0.0   0.0  100.0  0.0   ← 中央に熱源
0.0   0.0   0.0   0.0   ← 境界（固定）
```

### 1ステップ後
```
0.0   0.0   0.0   0.0
0.0   1.0   0.0   0.0   ← 熱が拡散
0.0   1.0  100.0  0.0   ← 熱源は固定
0.0   0.0   0.0   0.0
```

### 計算詳細（セル(1,1)の例）
```
laplacian = a[0,1] + a[2,1] + a[1,0] + a[1,2] - 4×a[1,1]
          = 0.0 + 0.0 + 0.0 + 100.0 - 4×0.0
          = 100.0

b[1,1] = a[1,1] + 0.01 × 100.0
       = 0.0 + 1.0
       = 1.0  ← 右隣の熱源から熱が伝わった
```

---

## パフォーマンス特性

### 計算量
- **1ステップ**: `(N-2) × (M-2)` 回の計算
- **全体**: `steps × (N-2) × (M-2)` 回
- 例: 1024×1024、100ステップ → 約1億回

### メモリアクセスパターン
```
✅ 良い点: 行優先の順次アクセス（キャッシュ効率良）
⚠️  問題点: 上下の行アクセス（キャッシュミス発生）
```

### 並列化の可能性
- ✅ **各格子点の計算は独立** → 並列化可能
- ⚠️ **境界データの同期が必要** → 次のステップで実装
