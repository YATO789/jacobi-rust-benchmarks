# Jacobi法ベンチマーク 分析ガイド

## 1. 研究の3つの柱

### 1.1 メモリ安全機構のコスト（Rust Safe vs Unsafe）

**仮説:**
- Rustの境界チェックは数%のオーバーヘッドを生む
- Mutexによる安全な同期はunsafeな生ポインタアクセスより遅い

**測定方法:**
```
オーバーヘッド(%) = (Rust Safe - Rust Unsafe) / Rust Unsafe × 100
```

**着目点:**
- シングルスレッド: 純粋なメモリ安全コスト
- 並列版: 同期機構の安全性コスト
- グリッドサイズ依存性: キャッシュ効果の影響

### 1.2 言語間性能差（C vs Rust）

**仮説:**
- 最適化されたCとRust Unsafeは同等の性能
- コンパイラの最適化能力の違いが出る

**測定方法:**
```
性能比 = C実行時間 / Rust Unsafe実行時間
```

**着目点:**
- 1.0に近い = 同等の性能
- <1.0 = Rustの方が速い
- >1.0 = Cの方が速い

### 1.3 同期手法のコスト比較

**4つの手法:**
1. Barrier（バリア同期）
2. Atomic Counter（アトミックカウンタ）
3. OpenMP/Rayon（高レベルライブラリ）
4. Single Thread（ベースライン）

**測定方法:**
```
並列化効率 = Single Thread時間 / 並列版時間 / スレッド数
```

**着目点:**
- 理想は1.0（完璧なスケーリング）
- 同期オーバーヘッドで効率低下
- グリッドサイズによる変化

## 2. なぜ比較するのか？（研究動機の候補）

### A. 実用的動機（推奨）

**「高性能計算におけるRust採用の実証的評価」**
- HPC分野ではC/Fortranが主流
- Rustは安全性を提供するが性能犠牲は許されない
- → 実アプリケーション（Jacobi法）で定量評価

**主張の構成:**
1. 安全性は重要（メモリバグによる計算誤差を防ぐ）
2. しかし性能犠牲は許容できない
3. 本研究で両立可能性を検証

### B. 学術的動機

**「Zero-cost abstractionの実証検証」**
- Rustは「抽象化のコストゼロ」を謳う
- → 実測でどこまで達成されているか検証

**着目点:**
- Unsafe Rustがベースライン（C相当）
- Safe Rustとの差が「安全性のコスト」
- 理論と実装のギャップ分析

### C. 教育的動機

**「並列プログラミング学習教材」**
- 同じアルゴリズムの複数実装を比較
- 安全性とトレードオフを体験的に学ぶ

## 3. 結論の導き方（分析手順）

### ステップ1: データの可視化

**グラフ作成案:**
1. **グリッドサイズ vs 実行時間**（各手法別）
   - X軸: グリッドサイズ（64～2048）
   - Y軸: 実行時間（秒）
   - 線: C, Rust Safe, Rust Unsafe × 各同期手法

2. **安全性オーバーヘッド vs グリッドサイズ**
   - X軸: グリッドサイズ
   - Y軸: オーバーヘッド（%）
   - 線: 各同期手法別

3. **並列化効率の比較**
   - 棒グラフ: 各手法の効率
   - グループ: グリッドサイズ別

### ステップ2: データから読み取れる傾向

**既存データ(prod_result.txt)からの観察:**

#### 観察1: Unsafe Rustの優位性（驚きの結果）
```
1024×1024, Counter Sync:
C:           0.168335秒
Rust Unsafe: 0.154532秒 ← 8.9%高速！
```
→ なぜRustの方が速いのか？（要調査）

#### 観察2: 安全性コストはケース依存
```
1024×1024:
- Single Thread: 10.5%のオーバーヘッド
- Counter Sync:  14.4%のオーバーヘッド
- Barrier:       6.0%のオーバーヘッド
```
→ 同期手法によってコストが異なる

#### 観察3: グリッドサイズの影響
```
256×256, Counter Sync:
Rust Safe:   0.010558秒
Rust Unsafe: 0.009652秒
差: 9.4% ← 大きいグリッドより小さい
```
→ キャッシュ効果？アムダールの法則？

### ステップ3: 結論の構成

**推奨構成:**

1. **導入**
   - 研究背景: HPCにおけるメモリ安全性の重要性
   - 課題: 安全性と性能の両立
   - 目的: Rustの実用性評価

2. **手法**
   - Jacobi法の実装詳細
   - 6つの実装（C×2, Safe Rust×2, Unsafe Rust×2）
   - ベンチマーク環境

3. **結果**
   - グラフ3つ（上記参照）
   - 定量データ（表形式）

4. **考察**
   - **発見1**: Unsafe RustはCと同等か若干優れる
     - 理由: LLVM最適化、キャッシュライン整列
   - **発見2**: Safe Rustのオーバーヘッドは5-15%
     - 許容範囲か？（議論の余地）
   - **発見3**: 同期手法の選択が最も重要
     - Atomic CounterがBarrierより高速（多くのケース）

5. **結論**
   - HPC分野でもRust採用は現実的
   - Unsafeは最小限に抑えつつ性能確保可能
   - 同期戦略の最適化が鍵

## 4. 追加実験の提案

### より深い分析のために:

#### 実験1: プロファイリング
```bash
# perf（Linux）やInstruments（macOS）でホットスポット特定
cargo build --release
perf record -g ./target/release/jacobi-rust-benchmarks
perf report
```
→ どこで時間を使っているか可視化

#### 実験2: スレッド数の変化
```bash
# 現在は2スレッド固定
# → 4, 8, 16スレッドではどうなる？
./jacobi_bench 8
cargo run --release -- 8
```
→ スケーラビリティ評価

#### 実験3: コンパイラフラグの影響
```rust
// Cargo.tomlで最適化レベル変更
[profile.release]
opt-level = 3
lto = true
codegen-units = 1
```
→ 最適化の効果測定

#### 実験4: SIMD命令の利用
```rust
// aligned-vecを活用したSIMD最適化
// → さらなる高速化の可能性
```

## 5. レポート執筆のTips

### 良い研究レポートの要素:

1. **明確な問い**
   - 「RustはHPCで使えるか？」
   - 定量的に答えられる問いを設定

2. **再現性**
   - 全コードをGitHubで公開
   - ベンチマーク手順を詳細に記述
   - 環境情報（CPU、OS、コンパイラバージョン）

3. **批判的分析**
   - 良い結果だけでなく制約も記述
   - 「なぜその結果になったか」の考察
   - 統計的有意性（標準偏差も報告）

4. **関連研究との比較**
   - 既存のRust HPC研究
   - C/Fortranベンチマーク
   - 他の並列化手法（MPI, GPU）

5. **将来への展望**
   - 3D問題への拡張
   - より大規模な問題
   - 他のHPCアルゴリズム

## 6. よくある落とし穴

### 避けるべきこと:

❌ **単一実行の結果で判断**
   - 複数回実行して平均・分散を報告

✅ **統計的な評価**
   - 最低10回の測定
   - 外れ値の除外基準を明記

❌ **環境情報の省略**
   - CPUクロック、キャッシュサイズ重要

✅ **詳細な環境記述**
   - `lscpu`, `sysctl hw`の出力を記録

❌ **デバッグビルドでの測定**
   - 必ず`--release`ビルドで測定

✅ **最適化の徹底**
   - リリースビルド
   - LTO有効化
   - 適切なCPUフラグ

## 7. 次のアクション

以下の順で進めることを推奨:

1. ✅ **データ整理**（既に完了）
   - prod_result.txtに複数サイズのデータあり

2. **可視化スクリプト作成**
   - PythonでMatplotlib/Seaborn使用
   - グラフ3種類を自動生成

3. **統計分析**
   - 平均・標準偏差の計算
   - t検定で有意差を確認

4. **考察の執筆**
   - 「なぜ」を深掘り
   - ソースコードと照らし合わせ

5. **追加実験**（必要に応じて）
   - プロファイリング
   - スレッド数変更

6. **レポート完成**
   - 構成に沿って執筆
   - 図表番号と参照を整備
